[
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Installing the Luna Server Image The SDK communicates with a Luna server instance using gRPC. Cobalt distributes a Docker image that contains the Luna server binary and model files.\n Contact Cobalt to get a link to the image file in AWS S3. This link will expire in two weeks, so be sure to download the file to your own server.\n Download with the AWS CLI if you have it, or with curl:\nURL=\u0026#34;the url sent by Cobalt\u0026#34; IMAGE_NAME=\u0026#34;name you want to give the file (should end with the same extension as the url, usually bz2)\u0026#34; curl $URL -L -o $IMAGE_NAME Load the docker image\ndocker load \u0026lt; $IMAGE_NAME This will output the name of the image (e.g. luna-demo-en_us-16).\n Start the Luna service\ndocker run -p 9001:9001 --name cobalt luna-demo-en_us-16 That will start listening for grpc commands on port 9001. You can replace --name cobalt with any name you want to give the docker container. The name simply provides a way to refer back to the running container.\n  Client Example The sdk-luna repo contains example code with subdirectories for various languages to build a demo client application.\nThe demo client creates a command-line interface that allows a user to submit text to Luna and receive back the synthesized audio. The client applications require a config file to specify the server information and an audio playback application. The playback application can be anything so long as it accepts formatted audio data from stdin. To run the application, do the following:\n # After building via the `go build` command, run the CLI cd /path/to/sdk-luna/examples/go ./luna-cli -config /path/to/config.toml  # After setting up an environment to use the Luna module, run the CLI cd /path/to/sdk-luna/examples/python python3 luna-cli.py -config /path/to/config.toml  # After building the example cd /path/to/build/directory ./luna-cli -config /path/to/config.toml   \nOnce the application is running, simply enter the text to synthesize at the prompt.\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/using-luna-sdk/",
	"title": "Using Luna SDK",
	"tags": [],
	"description": "",
	"content": " This section describes how to use the SDK for currently supported languages. For unsupported languages, please see the Luna API reference, or contact us to request support for your preferred language.\nContents  Including the SDK Gives language-specific instructions about how to add the SDK to your project.\n    Error Handling Describes how errors from the SDK are reported.\n  \n Connecting to the Server Describes how to connect to a running Luna server instance.\n  \n Synthesis Configuration Specify the TTS configuration for speech synthesis.\n  \n Batch Synthesis Describes how to synthesize audio in batch mode.\n  \n Streaming Synthesis Describes how to stream synthesized audio as it is generated.\n   \n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/using-luna-sdk/include/",
	"title": "Including the SDK",
	"tags": [],
	"description": "Gives language-specific instructions about how to add the SDK to your project.",
	"content": " Language-specific instructions to include the SDK in your project are given below.\nC++ To use the Luna SDK in a C++ project, you must first download the SDK from GitHub. To help simplify the build process, the C++ SDK uses CMake, although it is possible to use a different build system with some additional work. Details for building and including the SDK in a C++ project are described in detail in this README file.\nGo The Go SDK supports Go modules and requires Go 1.12 or later. To use the SDK, import this package into your application:\nimport ( \u0026#34;github.com/cobaltspeech/sdk-luna/grpc/go-luna\u0026#34; \u0026#34;github.com/cobaltspeech/sdk-luna/grpc/go-luna/lunapb\u0026#34; ) Note When using Go, it is not necessary to download the SDK using git (unless you want to build the example code). The `go build` command will automatically fetch the sdk-luna code from GitHub to use in your Go project.  \nPython The Python SDK requires Python v3.5.0 or greater. The SDK may be installed from GitHub using pip:\npip install \u0026#34;git+https://github.com/cobaltspeech/sdk-luna#egg=cobalt-luna\u0026amp;subdirectory=grpc/py-luna\u0026#34; Once installed, simply import the Luna module to use the SDK:\nimport luna # Or import the required classes from luna.client import LunaClient from luna.luna_pb2 import SynthesizeRequest, SynthesizerConfig"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/using-luna-sdk/errors/",
	"title": "Error Handling",
	"tags": [],
	"description": "Describes how errors from the SDK are reported.",
	"content": " The Luna SDK reports errors and client applications should be prepared to handle them appropriately. For the sake of clarity, most examples in the documentation do not fully demonstrate how to handle errors, preferring instead to focus on the topic at hand. Full examples, with proper error handling, can be found at our GitHub example folder.\nA brief description of how errors are handled for each language is given below.\nC++ The C++ SDK uses exceptions to report errors. Errors originating from the SDK will have the class type LunaException, which inherits from the std::exception class. To handle these errors, simply create a try-catch block around the SDK code. For example:\ntry { // Call SDK functions in here. The function calls may be in this  // try block, or within functions that the try block calls. } catch (const LunaException \u0026amp;err) { // Handle the error here. The specific error message can be  // retrieved using err.what(). }  Go The Go SDK uses the built-in error type to return errors from functions (see here for general information about handling errors in Go). Most SDK functions will return an error in addition to their other return values. For example:\n// Create a new client connection client, err := luna.NewClient(\u0026#34;127.0.0.1:9001\u0026#34;) if err != nil { // Handle the error here. } Python The Python SDK uses built-in exceptions to report errors. They can be handled by wrapping the client code in a try \u0026hellip; except statement. For example:\ntry: # Call SDK functions in here. The SDK functions may be # called directly, or within other functions that this # block eventually calls. except BaseException as err: # Handle the error here. To have better control over how # individual errors are handled, you may use more concrete # exception types in the except statement. finally: # Do any final cleanup here."
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/using-luna-sdk/connecting/",
	"title": "Connecting to the Server",
	"tags": [],
	"description": "Describes how to connect to a running Luna server instance.",
	"content": "Once you have the Luna server up and running, you are ready to create a client connection.\nFirst, you need to know the address (host:port) where the server is running. This document will assume the values 127.0.0.1:9001, but these can be replaced with your server address in actual code.\nDefault Connection The following code snippet connects to the server and queries its version. It uses our recommended default setup, expecting the server to be listening on a TLS encrypted connection.\n package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/cobaltspeech/sdk-luna/grpc/go-luna\u0026#34; ) const serverAddr = \u0026#34;127.0.0.1:9001\u0026#34; func main() { client, err := luna.NewClient(serverAddr) if err != nil { log.Fatal(err) } // Be sure to close the client when we are done with it.  defer client.Close() version, err := client.Version(context.Background()).Version if err != nil { log.Fatal(err) } fmt.Println(version) }  from luna.client import LunaClient client = LunaClient(service_address=\u0026#34;localhost:9001\u0026#34;) version = client.Version().version print(\u0026#34;Luna version {}\u0026#34;.format(version))  // File - main.cpp  #include \u0026#34;luna_client.h\u0026#34; #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt; const char* serverAddr = \u0026#34;127.0.0.1:9001\u0026#34;; int main(int argc, char *argv[]) { LunaClient client(serverAddr, true); std::string version = client.lunaVersion(); std::cout \u0026lt;\u0026lt; \u0026#34;Luna version: \u0026#34; \u0026lt;\u0026lt; version \u0026lt;\u0026lt; std::endl; return 0; }    \nInsecure Connection It is sometimes required to connect to Luna server without TLS enabled (during debugging, for example). Note that if the server has TLS enabled, attempting to connect with an insecure client will fail.\nTo create an insecure connection, do the following when creating the client:\n client, err := luna.NewClientWithInsecure(serverAddr)  client = LunaClient.with_insecure(service_address=\u0026#34;localhost:9001\u0026#34;)  LunaClient client(serverAddr, false);    \nClient Authentication In our recommended default setup, TLS is enabled in the gRPC setup, and when connecting to the server, clients validate the server\u0026rsquo;s SSL certificate to make sure they are talking to the right party. This is similar to how \u0026ldquo;https\u0026rdquo; connections work in web browsers.\nIn some setups, it may be desired that the server should also validate clients connecting to it and only respond to the ones it can verify. If your Luna server is configured to do client authentication, you will need to present the appropriate certificate and key when connecting to it.\nPlease note that in the client-authentication mode, the client will still also verify the server\u0026rsquo;s certificate, and therefore this setup uses mutually authenticated TLS. This can be done with:\n // certfile is a path to the ssl certificate file certfile=\u0026#34;/path/to/cert.pem\u0026#34; client, err := luna.NewClientWithCertFile(serverAddr, certfile)  # certfile is a path to the ssl certificate file certfile=\u0026#34;/path/to/cert.pem\u0026#34; client = LunaClient.with_cert_file(service_address=\u0026#34;localhost:9001\u0026#34;, certfile=certfile)  // Currently unsupported in C++.    \n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/using-luna-sdk/synthesis-config/",
	"title": "Synthesis Configuration",
	"tags": [],
	"description": "Specify the TTS configuration for speech synthesis.",
	"content": " Before we can run text-to-speech, the client needs to specify the configuration Luna should use to generate the audio. The Luna options include the specific voice model, the audio encoding, and the sample size. Except where noted, these options apply to both batch synthesis and streaming synthesis.\nVoice ID Voice models are defined in the Luna server config file, and the client can get a list of available voice models using the ListVoices method.\n // Get the list of voices from Luna response, err := client.ListVoices(context.Background()) // Display the list fmt.Printf(\u0026#34;Available voices:\\n\u0026#34;) for _, voice := range response.Voices { fmt.Printf(\u0026#34; Name: %s ID: %s\\n\u0026#34;, voice.Name, voice.Id) }  # Get the list of voices from Luna response = client.ListVoices() # Display the list print(\u0026#34;Available voices:\u0026#34;) for v in response.voices: print(\u0026#34; Name: {} ID: {}\u0026#34;.format(v.name, v.id))  // Get the list of voices from Luna std::vector\u0026lt;LunaVoice\u0026gt; voices = client.listVoices(); // Display the list std::cout \u0026lt;\u0026lt; \u0026#34;Available voices:\u0026#34; \u0026lt;\u0026lt; std::endl; for (const LunaVoice \u0026amp;v : voices) { std::cout \u0026lt;\u0026lt; \u0026#34; Name: \u0026#34; \u0026lt;\u0026lt; v.name() \u0026lt;\u0026lt; \u0026#34; ID: \u0026#34; \u0026lt;\u0026lt; v.id() \u0026lt;\u0026lt; std::endl; }    \nThe API requires the voice ID to be specified as part of the TTS synthesis request. The voice ID for each model is defined in the server\u0026rsquo;s config file.\nAudio Encoding The API requires that the audio encoding also be specified as part of the TTS synthesis request. The supported encodings are listed in the Luna API Reference.\nNote Audio encoding does not affect the sample rate of the generated audio. Sample rate is an intrisic part of the Luna voice model being used. Make sure your application uses a sample rate that matches the model. If you are using a custom model, be sure to inform Cobalt of your desired sample rate.  \nBuffer Size (Optional) When running streaming synthesis, a client may optionally specify a buffer size. If set (and not zero), the server will wait until the buffer is full before sending the audio data to the client. In the case where the entire generated audio is less than the buffer size, the samples will be returned when synthesis is complete. If the buffer size is not set, audio data will be returned as soon as it becomes available on the server.\nExample Below is an example showing how client code should set up the synthesis config.\n // Set up the synthesis config with the desired voice and encoding synthConfig := \u0026amp;lunapb.SynthesizerConfig{ VoiceId: \u0026#34;1\u0026#34;, // As defined in the Luna server config file  Encoding: lunapb.SynthesizerConfig_RAW_LINEAR16, // If setting the buffer size for streaming, include this param  // with the application\u0026#39;s desired buffer size.  NSamples: 8096, }  # Set up the synthesis config with the desired voice and encoding synth_config = SynthesizerConfig( voice_id=\u0026#34;1\u0026#34;, # As defined in the Luna server config file encoding=SynthesizerConfig.RAW_LINEAR16, # If setting the buffer size for streaming, include this arg with # the application\u0026#39;s desired buffer size. n_samples=8096)  // Set up the synthesis config with the desired voice and encoding cobaltspeech::luna::SynthesizerConfig synthConfig; synthConfig.set_voice_id(\u0026#34;1\u0026#34;); // As defined in the Luna server config file synthConfig.set_encoding(cobaltspeech::luna::SynthesizerConfig::RAW_LINEAR16); // If setting the buffer size for streaming, include this line with the // application\u0026#39;s desired buffer size. synthConfig.set_n_samples(8096);    \n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/using-luna-sdk/batch/",
	"title": "Batch Synthesis",
	"tags": [],
	"description": "Describes how to synthesize audio in batch mode.",
	"content": " Batch synthesis generates audio data from text and waits for synthesis to complete before returning any data to the client. Once synthesis has completed, all of the generated audio data is returned. The benefit of using this method is its simplicity - a client submits text and receives all the generated audio for the text. However, the downsides to this method include:\n Slower response time - must wait for synthesis to complete before receiving audio. Data packet size - if the text to synthesize is very large, the returned audio will also be very large. All that data must be transmitted over the network connection and stored in memory until the client application is finished using it.  Once generated, it is the client code’s responsibility to handle the returned audio, whether it sends it to an output device (e.g., speakers), saves it to a file, or simply discards it.\nExample Assuming the synthesis configuration has been set up previously, here is an example showing how to use the batch synthesis method:\n // Make the synthesis request. request := \u0026amp;lunapb.SynthesizeRequest{ Config: synthConfig, Text: \u0026#34;this is an awesome sentence\u0026#34;, } response, err := client.Synthesize(context.Background(), request) // Do something interesting with the returned audio. fmt.Printf(\u0026#34;Received %v bytes of audio.\\n\u0026#34;, len(response.Audio))  # Make the synthesis request. text = \u0026#34;this is an awesome sentence\u0026#34; request = SynthesizeRequest(config=synth_config, text=text) response = client.Synthesize(request) # Do something interesting with the returned audio. print(\u0026#34;Received {} bytes of audio.\u0026#34;.format(len(response.audio)))  // Make the synthesis request. std::string text = \u0026#34;this is an awesome sentence\u0026#34;; ByteVector audio = client.synthesize(synthConfig, text); // Do something interesting with the returned audio. std::cout \u0026lt;\u0026lt; \u0026#34;Received \u0026#34; \u0026lt;\u0026lt; audio.size() \u0026lt;\u0026lt; \u0026#34; bytes of audio.\u0026#34; \u0026lt;\u0026lt; std::endl;    \n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/using-luna-sdk/streaming/",
	"title": "Streaming Synthesis",
	"tags": [],
	"description": "Describes how to stream synthesized audio as it is generated.",
	"content": " Unlike batch synthesis, streaming synthesis begins to return the generated audio data to the client as soon as it is ready, sending multiple data packets until synthesis has completed. While this method is slightly more complex than batch synthesis, it brings the following benefits:\n Faster response time - a client may begin to use data as soon as it receives. This allows a client to begin audio playback even before synthesis is complete. Smaller data packet size - because the audio is sent in multiple messages over the gRPC stream, each packet will carry less data than the batch method.  This makes it possible to submit larger sentences to Luna without running out of memory. Optionally, a buffer size may be specified to give more control over the amount of data transmitted over the network connection at a time.   Once generated, it is the client code’s responsibility to handle the returned audio, whether it sends it to an output device (e.g., speakers), saves it to a file, or simply discards it.\nExample Assuming the synthesis configuration has been set up previously, here is an example showing how to use the streaming synthesis method:\n // Create the synthesis stream request := \u0026amp;lunapb.SynthesizeRequest{ Config: synthConfig, Text: \u0026#34;this is an even better sentence\u0026#34;, } stream, err := client.SynthesizeStream(context.Background(), request) // Wait for audio data from the server until the stream is closed, which // will happen when synthesis is complete. for { // Get the next response from the server  response, err := stream.Recv() // This indicates the stream has finished.  if err == io.EOF { break } if err != nil { return err } // Do something interesting with the audio  fmt.Printf(\u0026#34;Received %v bytes of audio.\\n\u0026#34;, len(response.Audio)) } fmt.Printf(\u0026#34;Synthesis complete.\\n\u0026#34;)  # Create the synthesis stream text = \u0026#34;this is an even better sentence\u0026#34; request = SynthesizeRequest(config=synth_config, text=text) stream = client.SynthesizeStream(request) # Wait for audio data from the server until the stream is closed, which # will happen when synthesis is complete. for response in stream: # Do something interesting with the audio print(\u0026#34;Received {} bytes of audio.\u0026#34;.format(len(response.audio))) print(\u0026#34;Synthesis complete.\u0026#34;)  // Create the synthesis stream std::string text = \u0026#34;this is an even better sentence\u0026#34;; LunaSynthesizerStream stream = client.synthesizeStream(synthConfig, text); // Wait for audio data from the server until the stream is closed, which // will happen when synthesis is complete. ByteVector audio; while(stream.receiveAudio(audio)) { // Do something interesting with the audio  std::cout \u0026lt;\u0026lt; \u0026#34;Received \u0026#34; \u0026lt;\u0026lt; audio.size() \u0026lt;\u0026lt; \u0026#34; bytes of audio.\u0026#34; \u0026lt;\u0026lt; std::endl; } stream.close(); std::cout \u0026lt;\u0026lt; \u0026#34;Synthesis complete.\u0026#34; \u0026lt;\u0026lt; std::endl;    \n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/protobuf/",
	"title": "Luna API Reference",
	"tags": [],
	"description": "",
	"content": " The Luna API is defined using gRPC and protocol buffers. This section of the documentation is auto-generated from the protobuf file. It describes the data types and functions defined in the spec. The \u0026ldquo;messages\u0026rdquo; below correspond to the data structures to be used, and the \u0026ldquo;service\u0026rdquo; contains the methods that can be called.\nluna.proto Service: Luna Service that implements the Cobalt Luna Text-to-Speech API\n   Method Name Request Type Response Type Description     Version VersionRequest VersionResponse Queries the Version of the Server.   ListVoices ListVoicesRequest ListVoicesResponse Retrieves a list of available text-to-speech voices.   Synthesize SynthesizeRequest SynthesizeResponse Performs synchronous text-to-speech generation.   SynthesizeStream SynthesizeRequest SynthesizeResponse Performs streaming text-to-speech generation, where the synthesized speech is streamed to the client as it is being generated.    Message: ListVoicesRequest The top-level message sent by the client for the ListVoices method.\nThis message is empty and has no fields.\nMessage: ListVoicesResponse The message sent by the server for the ListVoices method.\n   Field Type Label Description     voices Voice repeated List of voices available for use that match the request.    Message: SynthesizeRequest The top-level message sent by the client for the Synthesize and SynthesizeStream methods.\n   Field Type Label Description     config SynthesizerConfig  Provides configuration for the text-to-speech engine.   text string  The text to generate speech for.    Message: SynthesizeResponse The message returned to the client by the Synthesize and SynthesizeStream methods.\n   Field Type Label Description     audio bytes  Audio samples of the generated speech. The samples will have the encoding specified in the SynthesizerConfig.AudioEncoding field of the request.    Message: SynthesizerConfig Configuration for setting up the text-to-speech engine.\n   Field Type Label Description     voice_id string     encoding SynthesizerConfig.AudioEncoding  Encoding of the synthesized speech. If not specified, defaults to RAW_FLOAT32.   n_samples uint64  Optional field for streaming synthesis. If not zero, waits until n_samples are generated before sending the audio data to the client. In the case that the entire generated audio is less than n_samples, the samples will be returned when synthesis is complete.    Message: VersionRequest The top-level message sent by the client for the Version method.\nThis message is empty and has no fields.\nMessage: VersionResponse The message sent by the server for the Version method.\n   Field Type Label Description     version string      Message: Voice Description of a Luna Voice\n   Field Type Label Description     id string  Unique identifier of the voice. This identifier is used to choose the voice during a synthesis request, and is specified in the SynthesizerConfig message.   name string  Name of the voice. This is a concise name describing the voice, and maybe presented to the end-user, for example, to help which voice to choose for their TTS task.    Enum: SynthesizerConfig.AudioEncoding Supported audio encodings. Unless otherwise noted, the sample rate is defined by the voice model.\n   Name Number Description     RAW_LINEAR16 0 Raw (headerless) uncompressed 16-bit signed little endian samples (linear PCM), single channel.   RAW_FLOAT32 1 Raw (headerless) uncompressed 32-bit floating-point little endian samples (PCM), single channel.    Scalar Value Types    .proto Type Notes Go Type Python Type C++ Type     double  float64 float double   float  float32 float float   int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int int32   int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 int/long int64   uint32 Uses variable-length encoding. uint32 int/long uint32   uint64 Uses variable-length encoding. uint64 int/long uint64   sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int32   sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 int/long int64   fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int uint32   fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 int/long uint64   sfixed32 Always four bytes. int32 int int32   sfixed64 Always eight bytes. int64 int/long int64   bool  bool boolean bool   string A string must always contain UTF-8 encoded or 7-bit ASCII text. string str/unicode string   bytes May contain any arbitrary sequence of bytes. []byte str string    "
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Luna SDK \u0026ndash; Cobalt\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/",
	"title": "Luna SDK Documentation",
	"tags": [],
	"description": "",
	"content": " Luna API Overview Luna is Cobalt’s text to speech (TTS) engine. It can be deployed on-prem and accessed over the network or on your local machine via an API. We currently support Go, Python, and C++ and are adding support for more languages.\nFrom the API\u0026rsquo;s perspective, the process of generating audio data is fairly straightforward. After establishing a connection with the Luna server, a client submits text to Luna, and Luna returns synthesized audio data that mimics human speech.\nFor information about installing and running the Luna server, see the Getting Started section. For details about using the SDK, see Using Luna SDK.\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]