[
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/getting-started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/getting-started/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Instructions for installing the SDK are language-specific.\nGo The Go SDK supports go modules. We recommend using Go 1.11 or later. You can download the sdk using:\ngo get -u github.com/cobaltspeech/sdk-luna/grpc/go-luna\nAlternatively, if you just import github.com/cobaltspeech/sdk-luna/grpc/go-luna in your application and run go mod tidy, it will be fetched automatically.\nPython The Python SDK supports installation via pip. We recommend Python 3.5 or later, and pip 19.0 or later. You can download the sdk using:\npip install \u0026quot;git+https://github.com/cobaltspeech/sdk-luna#egg=luna\u0026amp;subdirectory=grpc/py-luna\u0026quot;\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/",
	"title": "Cobalt&#39;s Luna SDK Documentation",
	"tags": [],
	"description": "",
	"content": " Luna SDK Luna is Cobalt\u0026rsquo;s text-to-speech engine. It can be bundled into your application as a library, or deployed on-prem and accessed over the network. This documentation refers to accessing the network-based luna server.\nCobalt will provide you with a package of Luna that contains the engine, your voice objects, and a server application. This server exports Luna\u0026rsquo;s functionality over the gRPC protocol. The https://github.com/cobaltspeech/luna-sdk repository contains the SDK that you can use in your application to communicate with the Luna server. This SDK is currently available for Go and Python languages; and we would be happy to talk to you if you need support for other languages. Most of the core SDK is generated automatically using the gRPC tools, and Cobalt provides a top level package for more convenient API calls.\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/protobuf/",
	"title": "Protobuf Reference",
	"tags": [],
	"description": "",
	"content": "The Luna API is specified as a proto file. This section of the documentation is auto-generated from the spec. It describes the data types and functions defined in the spec. The “messages” below correspond to the data structures to be used, and the “service” contains the methods that can be called. luna.proto Service: Luna Service that implements the Cobalt Luna Text-to-Speech API Method Name Request Type Response Type Description Version VersionRequest VersionResponse Queries the Version of the Server ListVoices ListVoicesRequest ListVoicesResponse Retrieves a list of available text-to-speech voices Synthesize SynthesizeRequest SynthesizeResponse Performs synchronous text-to-speech generation.\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/getting-started/quickstart/",
	"title": "Quickstart",
	"tags": [],
	"description": "",
	"content": "Once you have your Luna server up and running, let\u0026rsquo;s see how we can ask it to synthesize speech for some text!\nFirst, you need to know the address (host:port) where the server is running. This document will assume the values 127.0.0.1:2727, but be sure to change those to point to your server instance. Port 2727 is the default port that the luna server binds to.\nThe following code snippet queries the server for a list of available voices, and uses the first listed voice to run text to speech.\n package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/cobaltspeech/sdk-luna/grpc/go-luna\u0026#34; \u0026#34;github.com/cobaltspeech/sdk-luna/grpc/go-luna/lunapb\u0026#34; ) const serverAddress = \u0026#34;127.0.0.1:2727\u0026#34; func main() { // Create a Luna Client  client, err := luna.NewClient(serverAddress) if err != nil { // TODO: handle err  } // Clean up at the end  defer client.Close() // Get list of available voices  pbvoices, err := client.ListVoices(context.Background()) if err != nil { // TODO: handle err  } voices := pbvoices.Voices if len(voices) == 0 { // TODO: handle err  } // Choose the first voice  v := voices[0] // Request TTS  pbtts, err := client.Synthesize( context.Background(), \u0026amp;lunapb.SynthesizeRequest{ Config: \u0026amp;lunapb.SynthesizerConfig{ VoiceId: v.Id, }, Text: \u0026#34;hello world!\u0026#34;, }) if err != nil { // TODO: handle err  } // The generated speech is 32-bit float samples, at 48k samples per second.  // Do something with the samples.  fmt.Printf(\u0026#34;Received %d samples\\n\u0026#34;, len(pbtts.Samples)) }  from luna.client import LunaClient from luna import luna_pb2 as lunapb SERVER_ADDRESS = \u0026#34;127.0.0.1:2727\u0026#34; try: # Create a Luna Client client = LunaClient(SERVER_ADDRESS) # Retrieve a list of available voices pbvoices = client.ListVoices() # Choose the first voice for synthesis v = pbvoice.voices[0] # Request TTS pbtts = client.Synthesize( lunapb.SynthesizeRequest( config=lunapb.SynthesizerConfig(voice_id=v.id), text=\u0026#34;hello world!\u0026#34;)) # The generated speech is 32-bit float samples, at 48k samples per second. # Do something with the samples. print(\u0026#34;Received %dsamples\u0026#34; % len(pbtts.samples)) except Exception as err: # TODO: handle exceptions print(err)    "
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/getting-started/mutually_authenticated_tls/",
	"title": "Mutually Authenticated TLS",
	"tags": [],
	"description": "",
	"content": "In our recommended default setup, TLS is enabled in the gRPC setup, and when connecting to the server, clients check the server\u0026rsquo;s SSL certificate to verify that they are talking to an authentic server. This is similar to how \u0026ldquo;https\u0026rdquo; connections work in web browsers.\nIt may sometimes be required that both the client and server need to authenticate with each other when establishing the connection. This is possible by configuring the luna client with a valid certificate file, which it presents to the luna server when negotiating TLS connection. The server validates the certificate and only allows authentic clients to send requests to it.\nPlease contact us to discuss more details of this setup \u0026ndash; whether to use it and how to configure it.\n package main import ( \u0026#34;github.com/cobaltspeech/sdk-luna/grpc/go-luna\u0026#34; ) const serverAddress = \u0026#34;127.0.0.1:2727\u0026#34; func main() { // Create a Luna Client with specific SSL credentials  client, err := luna.NewClientWithCertFile(serverAddress, \u0026#34;/path/to/cert.pem\u0026#34;) if err != nil { // TODO: handle err  } // ... }  from luna.client import LunaClient SERVER_ADDRESS = \u0026#34;127.0.0.1:2727\u0026#34; # create a luna client with specific SSL credentials client = LunaClient.with_cert_file(SERVER_ADDRESS, \u0026#34;/path/to/cert.pem\u0026#34;)    "
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/protobuf/autogen-doc-cubic-proto/",
	"title": "Proto Generated Docs",
	"tags": [],
	"description": "",
	"content": " The Luna API is specified as a proto file. This section of the documentation is auto-generated from the spec. It describes the data types and functions defined in the spec. The \u0026ldquo;messages\u0026rdquo; below correspond to the data structures to be used, and the \u0026ldquo;service\u0026rdquo; contains the methods that can be called.\nluna.proto Service: Luna Service that implements the Cobalt Luna Text-to-Speech API\n   Method Name Request Type Response Type Description     Version VersionRequest VersionResponse Queries the Version of the Server   ListVoices ListVoicesRequest ListVoicesResponse Retrieves a list of available text-to-speech voices   Synthesize SynthesizeRequest SynthesizeResponse Performs synchronous text-to-speech generation.    Message: ListVoicesRequest The top-level message sent by the client for the ListVoices method.\nThis message is empty and has no fields.\nMessage: ListVoicesResponse The message sent by the server for the ListVoices method.\n   Field Type Label Description     voices Voice repeated List of voices available for use that match the request.    Message: SynthesizeRequest The top-level message sent by the client for the Synthesize method.\n   Field Type Label Description     config SynthesizerConfig  Provides configuration for the text-to-speech engine.   text string  The text to generate speech for.    Message: SynthesizeResponse The message returned to the client by the Synthesize method.\n   Field Type Label Description     samples float repeated Audio samples of the entire generated speech, in the 32-bit float encoding, single channel, sampled at 48KHz.    Message: SynthesizerConfig Configuration for setting up the text-to-speech engine.\n   Field Type Label Description     voice_id string      Message: VersionRequest The top-level message sent by the client for the Version method.\nThis message is empty and has no fields.\nMessage: VersionResponse The message sent by the server for the Version method.\n   Field Type Label Description     version string      Message: Voice Description of a Luna Voice\n   Field Type Label Description     id string  Unique identifier of the voice. This identifier is used to choose the voice during a synthesis request, and is specified in the SynthesizerConfig message.   name string  Name of the voice. This is a concise name describing the voice, and maybe presented to the end-user, for example, to help which voice to choose for their TTS task.    Scalar Value Types    .proto Type Notes Go Type Python Type     double  float64 float   float  float32 float   int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int   int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 int/long   uint32 Uses variable-length encoding. uint32 int/long   uint64 Uses variable-length encoding. uint64 int/long   sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int   sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 int/long   fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int   fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 int/long   sfixed32 Always four bytes. int32 int   sfixed64 Always eight bytes. int64 int/long   bool  bool boolean   string A string must always contain UTF-8 encoded or 7-bit ASCII text. string str/unicode   bytes May contain any arbitrary sequence of bytes. []byte str    "
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Luna SDK \u0026ndash; Cobalt\n"
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cobaltspeech.github.io/sdk-luna/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]